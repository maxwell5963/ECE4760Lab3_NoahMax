<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Your Project Title</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="stylesheet" href="styles.css">
</head>
<body>

  <header>
    <h1>Super Mario Recreation</h1>
    <p class="tagline">A retro‐inspired, Super Mario–style side-scroller running on a custom handheld console built around a Raspberry Pi Pico..</p>
    <nav>
      <ul>
        <li><a href="#intro">Introduction</a></li>
        <li><a href="#design">High-Level Design</a></li>
        <li><a href="#hw">Program/Hardware Design</a></li>
        <li><a href="#results">Results</a></li>
        <li><a href="#conclusions">Conclusions</a></li>
        <li><a href="#appendix">Appendix A</a></li>
      </ul>
    </nav>
  </header>

  <main>
    <!-- Introduction -->
    <section id="intro">
      <h2>Project Introduction</h2>
  <p>
    A retro‐inspired, Super Mario–style side-scroller built on a Raspberry Pi Pico. We designed and built a mini gaming console around the
    Raspberry Pi Pico to re-create the look and feel of an the original Super Mario Bros. We recreated the entire game from scratch using methods from the first three lab assignments.
    We heavy relied upon lab 2 (Galton Board) as the base for our game, as it was physics- and animation- heavy. We ended up with a nearly spot-on recreation of the original game, with 
    some considerations for the restrictions of the provided color palette, and some non-essential features cut due to time and resource constraints. 
  </p>
    </p>
      Players control Mario through four dedicated inputs. Two tactile buttons steer horizontal movement: pressing the left button moves Mario left, while the right button moves him right. 
      A separate jump button applies an upward velocity impulse against gravity, allowing Mario to clear gaps and enemies. Finally, a reset button instantly clears the screen and restarts the level, 
      re-initializes scores/enemies/time, giving players a quick way to retry. All inputs are sampled via GPIO each frame and handled in our Protothread–driven main loop to ensure responsive, 
      flicker-free gameplay.
    </p>
    </section>

    <!-- High-Level Design -->
    <section id="design">
      <h2>High-Level Design</h2>
      <ul>
        <li><strong>Rationale &amp; sources:</strong> Where the idea came from</li>
      </p>
        We are both fond of retro, scrolling-style games. We also both particularly enjoyed lab 2 and loved the idea of doing something that you can directly interact with. As such,
        we set out to create an as-accurate-as-possible recreation of the original Super Mario Bros. This idea also complemented our strengths well, as Noah is strong in areas dealing
        in physics, while Max is much better at front-end and the artistic side of things. This allowed us to each focus on a different part we were stronger at. 
      </p>
        <li><strong>Background math:</strong> Key formulas or algorithms</li>
      </p>
        At heart, the physics of the game are rooted in basic mechanics. Our physics core relies on simple Newtonian motion under constant gravitational acceleration, discretized per frame.
        We provide a hard-cap of his downward velocity in order to prevent runaway fall speeds. When the jump button is pressed at ground contact, we give Mario an instantaneous upward velocity boost, 
        after which gravity pulls him back down. Horizontal movement is handled by adding or subtracting a fixed speed each frame when the left or right button is held, but only if the tile-based collision 
        check indicates no solid block in the way. By converting Mario’s world coordinates into tile indices, we can efficiently test the few tiles around his feet and sides to prevent him from walking or 
        falling through walls.
      </p>
      </p>
        To create the illusion of a scrolling world much larger than the 640×480 display, we maintain a single “world_x” offset that follows Mario once he moves past the center threshold. Instead of moving Mario
        past that point, we shift the viewport by the same amount he would have moved, then redraw only the tiles and sprites visible in the new window. This technique keeps Mario visually centered while the 
        background glides by. Enemy Goombas use the same gravity-and-bounce rules as Mario, plus a constant patrol speed that reverses whenever they hit a wall; their sprite frames advance on a simple timer so 
        that their walking animation stays in sync with the game’s 60 Hz update loop.
      </p>
        <li><strong>Logical structure:</strong></li>
        We organized our game into distinct modules for simplicty. Each file was coupled with its own header file for easy compatibility between modules. We repurposed the animation.c file from Lab 2 and used
        it to serve as our main file. We have dedicated files for drawing sprites, drawing tiles/screen, collision/movement physics, games states, struct handling, storing level data, as well as a colors
        header file where we define our own shorthand definitions for the provided colors to make our arrays cleaner and easier to write/read visually. A summary of each is provided in the table below. 
      </p>
        <table>
  <thead>
    <tr>
      <th>File</th>
      <th>Purpose / Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>drawtile.h</code></td>
      <td>Declarations for tile‐map drawing routines and tile bitmap data.</td>
    </tr>
    <tr>
      <td><code>drawtile.c</code></td>
      <td>Implements functions to render individual tiles to the VGA buffer.</td>
    </tr>
    <tr>
      <td><code>colors.h</code></td>
      <td>Defines RGB color constants (e.g. <code>OB</code>, <code>YL</code>, <code>WT</code>).</td>
    </tr>
    <tr>
      <td><code>gamestates.h</code></td>
      <td>Enumerates the different game states (e.g. <code>PLAYING</code>, <code>GAME_OVER</code>).</td>
    </tr>
    <tr>
      <td><code>gamestates.c</code></td>
      <td>Implements the state‐machine logic for transitioning between menus, play, and game‐over screens.</td>
    </tr>
    <tr>
      <td><code>drawsprites.h</code></td>
      <td>Declares sprite rendering functions and animation frame constants.</td>
    </tr>
    <tr>
      <td><code>drawsprites.c</code></td>
      <td>Contains routines to draw and animate Mario, Goombas, coins, and other moving objects.</td>
    </tr>
    <tr>
      <td><code>drawscreen.h</code></td>
      <td>Function prototypes for drawing the level viewport and status bar.</td>
    </tr>
    <tr>
      <td><code>drawscreen.c</code></td>
      <td>Implements full‐screen redraws, including the scrolling tile window and HUD.</td>
    </tr>
    <tr>
      <td><code>animation.c</code></td>
      <td>Protothread‐based timers and animation schedulers (e.g. enemy walk cycles).</td>
    </tr>
    <tr>
      <td><code>movementphysics.h</code></td>
      <td>Declares physics update functions and constants (gravity, jump velocity).</td>
    </tr>
    <tr>
      <td><code>movementphysics.c</code></td>
      <td>Implements Mario and Goomba kinematics, collision detection, and boundary checks.</td>
    </tr>
    <tr>
      <td><code>initstructs.h</code></td>
      <td>Defines the data structures for characters, enemies, and game state.</td>
    </tr>
    <tr>
      <td><code>initstructs.c</code></td>
      <td>Initializes all game objects (position, velocity, alive flags, etc.) at startup/reset.</td>
    </tr>
    <tr>
      <td><code>leveldata.h</code></td>
      <td>Contains the raw, constant 16×421 tile map for Level 1.</td>
    </tr>
    <tr>
      <td><code>leveldata.c</code></td>
      <td>Copies the flash‐stored map into RAM and handles runtime modifications (e.g., Q‐block hits).</td>
    </tr>
  </tbody>
</table>

      </p>
      </p>
        In terms of intellectual property considerations, all graphics (tiles, sprites) are coded from scratch with
        different color palettes and simplified shapes. We opted against including sound/music, but these could easily
        have been sourced from the public domain or generated using AI tools. 
      </p>
      </ul>
    </section>

    <!-- Program/Hardware Design -->
    <section id="hw">
      <h2>Program/Hardware Design</h2>
      <ul>
        <li><strong>Program details:</strong> What was tricky to write?</li>
        <li><strong>Hardware details:</strong> How to reproduce your setup</li>
        <li><strong>External code/design:</strong> References to any third-party code</li>
        <li><strong>Dead ends:</strong> Things you tried that didn’t work</li>
      </ul>
    </section>

    <!-- Results -->
    <section id="results">
      <h2>Results of the Design</h2>
      <ul>
        <li><strong>Test data:</strong> Scope traces, waveforms, screenshots</li>
        <li><strong>Performance:</strong> Speed, interactivity, concurrency</li>
        <li><strong>Accuracy:</strong> Numeric errors, timing precision</li>
        <li><strong>Safety:</strong> Any protective measures you enforced</li>
        <li><strong>Usability:</strong> How others interacted with your demo</li>
      </ul>
    </section>

    <!-- Conclusions -->
    <section id="conclusions">
      <h2>Conclusions</h2>
      <ul>
        <li>How results met (or didn’t meet) your expectations</li>
        <li>What you’d change next time</li>
        <li>Standards compliance</li>
        <li>Intellectual property considerations:
          <ul>
            <li>Did you reuse or reverse-engineer any design?</li>
            <li>Non-disclosure agreements or patent issues?</li>
            <li>Any opportunities for patenting your work?</li>
          </ul>
        </li>
      </ul>
    </section>

    <!-- Appendix -->
    <section id="appendix">
      <h2>Appendix A: Permissions</h2>
      <p>This is the Cornell-required opt-in statement for inclusion on the course page:</p>
      <p>
        <label><input type="radio" name="opt" disabled> The group approves this report for inclusion on the course website.</label><br>
      </p>
      <p><em>(Remember: if you don’t opt-in, you lose 5 points!)</em></p>
    </section>
  </main>

  <footer>
    <p>&copy; Max Warner (mtw82), Noah Wilson (njw66)</p>
  </footer>

</body>
</html>

